import threading
import time
from contextlib import contextmanager

import httpx
import uvicorn


class ServerThread(threading.Thread):
    # Generated by Claude

    def __init__(self, app, host, port):
        super().__init__(daemon=True)
        self.app = app
        self.host = host
        self.port = port
        self.server = None

    def run(self):
        """Run the uvicorn server."""
        config = uvicorn.Config(
            self.app,
            host=self.host,
            port=self.port,
            log_level="error",  # Suppress logs during tests
            access_log=False,
        )
        self.server = uvicorn.Server(config)
        self.server.run()

    def stop(self):
        """Stop the server."""
        if self.server:
            self.server.should_exit = True


@contextmanager
def create_endpoint(app, host, port):
    # Mostly generated by Claude

    # Start server in background thread
    server_thread = ServerThread(app=app, host=host, port=port)
    server_thread.start()

    # Wait for server to be ready
    base_url = f"http://{host}:{port}"
    max_retries = 50
    retry_delay = 0.1

    for _ in range(max_retries):
        try:
            import httpx

            with httpx.Client() as client:
                response = client.get(f"{base_url}/health", timeout=1.0)
                if response.status_code == 200:
                    break
        except (httpx.ConnectError, httpx.TimeoutException):
            time.sleep(retry_delay)
    else:
        raise RuntimeError(f"Server failed to start on {base_url}")

    yield base_url

    # Cleanup: stop the server thread
    server_thread.stop()


class OAuthMock:
    def __init__(self, host="127.0.0.1", port=29313):
        self.host = host
        self.port = port
        self.base_url = None
        self._email = "test@example.com"
        self._endpoint_context = None

    def __enter__(self):
        from .oauth_mock import app

        self._endpoint_context = create_endpoint(app, self.host, self.port)
        self.base_url = self._endpoint_context.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self._endpoint_context:
            self._endpoint_context.__exit__(exc_type, exc_val, exc_tb)

    def set_email(self, email: str):
        response = httpx.post(f"{self.base_url}/set_email", data={"email": email})
        response.raise_for_status()
        return response.json()

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, value):
        self.set_email(value)
        self._email = value
