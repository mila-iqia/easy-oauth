"""Pytest configuration and fixtures."""

import threading
import time
from contextlib import contextmanager
from dataclasses import dataclass
from itertools import count
from pathlib import Path
from random import randint

import httpx
import pytest
import uvicorn
from serieux import Sources

from .app import make_app
from .oauth_mock import PORT as OAUTH_PORT
from .oauth_mock import app as oauth_app

_port = count(OAUTH_PORT + randint(1, 1000))


here = Path(__file__).parent


class ServerThread(threading.Thread):
    # Generated by Claude

    def __init__(self, app, host, port):
        super().__init__(daemon=True)
        self.app = app
        self.host = host
        self.port = port
        self.server = None

    def run(self):
        """Run the uvicorn server."""
        config = uvicorn.Config(
            self.app,
            host=self.host,
            port=self.port,
            log_level="error",  # Suppress logs during tests
            access_log=False,
        )
        self.server = uvicorn.Server(config)
        self.server.run()

    def stop(self):
        """Stop the server."""
        if self.server:
            self.server.should_exit = True


@contextmanager
def create_endpoint(app, host, port):
    # Mostly generated by Claude

    # Start server in background thread
    server_thread = ServerThread(app=app, host=host, port=port)
    server_thread.start()

    # Wait for server to be ready
    base_url = f"http://{host}:{port}"
    max_retries = 50
    retry_delay = 0.1

    for _ in range(max_retries):
        try:
            import httpx

            with httpx.Client() as client:
                response = client.get(f"{base_url}/health", timeout=1.0)
                if response.status_code == 200:
                    break
        except (httpx.ConnectError, httpx.TimeoutException):
            time.sleep(retry_delay)
    else:
        raise RuntimeError(f"Server failed to start on {base_url}")

    yield base_url

    # Cleanup: stop the server thread
    server_thread.stop()


@pytest.fixture(scope="session", autouse=True)
def oauth_endpoint():
    """
    Start the OAuth mock server in a background thread.

    Yields:
        str: The base URL of the mock OAuth server (e.g., "http://127.0.0.1:29313")
    """
    with create_endpoint(oauth_app, "127.0.0.1", OAUTH_PORT) as endpoint:
        yield endpoint


@pytest.fixture
def set_email(oauth_endpoint):
    def set_email(email):
        response = httpx.post(f"{oauth_endpoint}/set_email", data={"email": email})
        assert response.status_code == 200
        return email

    try:
        yield set_email
    finally:
        set_email("test@example.com")


@dataclass
class TokenInteractor:
    root: str
    email: str
    token: str

    @classmethod
    def make(cls, app, email):
        response = httpx.get(f"{app}/token", follow_redirects=True)
        assert response.status_code == 200
        token = response.json()["refresh_token"]
        return cls(app, email, token)

    def expect(self, response, expect=None):
        expect = 200 if expect is None else expect
        if response.status_code != expect:
            raise AssertionError(
                f"Expected status {expect}, got {response.status_code}: {response.text}"
            )
        return response

    def get(self, endpoint, expect=None, **data):
        response = httpx.get(
            f"{self.root}{endpoint}",
            headers={"Authorization": f"Bearer {self.token}"},
            params=data,
        )
        return self.expect(response, expect)

    def post(self, endpoint, expect=None, **data):
        response = httpx.post(
            f"{self.root}{endpoint}",
            headers={"Authorization": f"Bearer {self.token}"},
            json=data,
        )
        return self.expect(response, expect)


@pytest.fixture(scope="session")
def app():
    port = next(_port)
    with create_endpoint(make_app(Path(here / "appconfig.yaml")), "127.0.0.1", port) as endpoint:
        yield endpoint


@pytest.fixture
def user(app, set_email):
    def make_interactor(email):
        set_email(email)
        return TokenInteractor.make(app, email)

    yield make_interactor


@pytest.fixture
def app_write(tmpdir):
    port = next(_port)
    with create_endpoint(
        make_app(Path(here / "appconfig.yaml"), tmpdir), "127.0.0.1", port
    ) as endpoint:
        yield endpoint


@pytest.fixture
def user_write(app_write, set_email):
    def make_interactor(email):
        set_email(email)
        return TokenInteractor.make(app_write, email)

    yield make_interactor


@pytest.fixture
def app_force_user(tmpdir):
    @contextmanager
    def make(email):
        port = next(_port)
        sources = Sources(Path(here / "noauthconfig.yaml"), {"force_user": {"email": email}})
        with create_endpoint(make_app(sources, tmpdir), "127.0.0.1", port) as endpoint:
            yield endpoint

    yield make
