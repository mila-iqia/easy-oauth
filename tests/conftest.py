"""Pytest configuration and fixtures."""

import threading
import time
from dataclasses import dataclass
from itertools import count
from random import randint

import httpx
import pytest
import uvicorn

from .app import make_app
from .oauth_mock import PORT as OAUTH_PORT
from .oauth_mock import app as oauth_app

_port = count(OAUTH_PORT + randint(1, 1000))


class ServerThread(threading.Thread):
    # Generated by Claude

    def __init__(self, app, host, port):
        super().__init__(daemon=True)
        self.app = app
        self.host = host
        self.port = port
        self.server = None

    def run(self):
        """Run the uvicorn server."""
        config = uvicorn.Config(
            self.app,
            host=self.host,
            port=self.port,
            log_level="error",  # Suppress logs during tests
            access_log=False,
        )
        self.server = uvicorn.Server(config)
        self.server.run()

    def stop(self):
        """Stop the server."""
        if self.server:
            self.server.should_exit = True


def create_endpoint(app, host, port):
    # Mostly generated by Claude

    # Start server in background thread
    server_thread = ServerThread(app=app, host=host, port=port)
    server_thread.start()

    # Wait for server to be ready
    base_url = f"http://{host}:{port}"
    max_retries = 50
    retry_delay = 0.1

    for _ in range(max_retries):
        try:
            import httpx

            with httpx.Client() as client:
                response = client.get(f"{base_url}/health", timeout=1.0)
                if response.status_code == 200:
                    break
        except (httpx.ConnectError, httpx.TimeoutException):
            time.sleep(retry_delay)
    else:
        raise RuntimeError(f"Server failed to start on {base_url}")

    yield base_url

    # Cleanup: stop the server thread
    server_thread.stop()


@pytest.fixture(scope="session", autouse=True)
def oauth_endpoint():
    """
    Start the OAuth mock server in a background thread.

    Yields:
        str: The base URL of the mock OAuth server (e.g., "http://127.0.0.1:29313")
    """
    yield from create_endpoint(oauth_app, "127.0.0.1", OAUTH_PORT)


@pytest.fixture
def set_email(oauth_endpoint):
    def set_email(email):
        response = httpx.post(f"{oauth_endpoint}/set_email", data={"email": email})
        assert response.status_code == 200
        return email

    try:
        yield set_email
    finally:
        set_email("test@example.com")


@dataclass
class TokenInteractor:
    root: str
    email: str
    token: str

    @classmethod
    def make(cls, app, email):
        response = httpx.get(f"{app}/token", follow_redirects=True)
        assert response.status_code == 200
        token = response.json()["refresh_token"]
        return cls(app, email, token)

    def get(self, endpoint, expect=None, **data):
        response = httpx.get(
            f"{self.root}{endpoint}",
            headers={"Authorization": f"Bearer {self.token}"},
            params=data,
        )
        expect = 200 if expect is None else expect
        if response.status_code != expect:
            raise AssertionError(
                f"Expected status {expect}, got {response.status_code}: {response.text}"
            )
        return response

    def post(self, endpoint, expect=None, **data):
        response = httpx.post(
            f"{self.root}{endpoint}",
            headers={"Authorization": f"Bearer {self.token}"},
            json=data,
        )
        expect = 200 if expect is None else expect
        if response.status_code != expect:
            raise AssertionError(
                f"Expected status {expect}, got {response.status_code}: {response.text}"
            )
        return response


@pytest.fixture(scope="session")
def app():
    port = next(_port)
    yield from create_endpoint(make_app(), "127.0.0.1", port)


@pytest.fixture
def user(app, set_email):
    def make_interactor(email):
        set_email(email)
        return TokenInteractor.make(app, email)

    yield make_interactor


@pytest.fixture
def app_write(tmpdir):
    port = next(_port)
    yield from create_endpoint(make_app(tmpdir), "127.0.0.1", port)


@pytest.fixture
def user_write(app_write, set_email):
    def make_interactor(email):
        set_email(email)
        return TokenInteractor.make(app_write, email)

    yield make_interactor
